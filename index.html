<!DOCTYPE HTML>
<html>
  <head>
    <title>Food Recipes | Exhibit Facet Search</title>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <link rel="stylesheet" href="https://www.simile-widgets.org/styles/common.css" type="text/css" />
    <link rel="stylesheet" href="food-exhibit.css" type="text/css" />
    <link href="food-exhibit-data-500recipes.json" type="application/json" rel="exhibit/data" />
    <script src="https://api.simile-widgets.org/exhibit/current/exhibit-api.js"></script>
    <style>
      /* === Design System === */
      :root {
        --color-text-primary: #111827;
        --color-text-secondary: #4b5563;
        --color-text-tertiary: #6b7280;
        --color-accent: #2563eb;
        --color-accent-hover: #1d4ed8;
        --color-border: #e5e7eb;
        --color-bg-subtle: #f9fafb;
        --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
      }

      /* Modern font stack and base styles */
      body {
        font-family: var(--font-sans);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        color: var(--color-text-secondary);
        font-size: 15px;
        line-height: 1.6;
        background: #ffffff;
      }

      /* Typography Scale */
      h1 {
        font-size: 36px;
        font-weight: 700;
        letter-spacing: -0.03em;
        color: var(--color-text-primary);
        line-height: 1.2;
        margin: 0 0 8px 0;
      }

      h2 {
        font-size: 24px;
        font-weight: 700;
        letter-spacing: -0.02em;
        color: var(--color-text-primary);
        line-height: 1.3;
      }

      h3 {
        font-size: 18px;
        font-weight: 600;
        letter-spacing: -0.01em;
        color: var(--color-text-primary);
      }

      h4 {
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: var(--color-text-secondary);
      }

      p {
        color: var(--color-text-secondary);
        line-height: 1.6;
        margin: 0 0 12px 0;
      }

      /* Header Styling - Simple inline */
      #header {
        background: none;
        border: none;
        padding: 8px 20px;
        margin: 0;
      }

      #header table,
      #header tbody,
      #header tr,
      #header td {
        display: inline !important;
        padding: 0 !important;
        margin: 0 !important;
        background: none !important;
        border: none !important;
      }

      #header h1 {
        display: inline;
        margin: 0;
        padding: 0;
        font-size: 20px;
        line-height: 1;
        font-weight: 700;
        color: var(--color-text-primary);
      }

      #header p {
        display: none;
      }

      /* Align collection summary (500 Recipes) */
      .exhibit-collectionSummaryWidget {
        display: inline-block;
        margin: 0 0 10px 0;
        padding: 0;
        font-size: 24px;
        font-weight: 600;
        color: var(--color-text-primary);
        vertical-align: baseline;
      }

      .exhibit-collectionSummaryWidget-count {
        font-size: 32px;
        font-weight: 700;
        color: var(--color-text-primary);
        margin-right: 4px;
      }

      .exhibit-collectionSummaryWidget-description {
        font-size: 16px;
        font-weight: 500;
        color: var(--color-text-secondary);
      }

      /* Hide the built-in Exhibit reset/clear links */
      .exhibit-collectionSummaryWidget a[href*="clearRestrictions"],
      .exhibit-collectionSummaryWidget-resetFiltersLink,
      a[href*="clearRestrictions"],
      a[href*="clearAllRestrictions"] {
        display: none !important;
      }

      /* Align viewPanel content properly */
      [data-ex-role="viewPanel"] {
        margin-top: 0;
        padding-top: 0;
      }

      /* Facet Styling */
      .exhibit-facet-header {
        font-family: var(--font-sans);
        font-weight: 600;
        font-size: 13px;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: var(--color-text-primary);
        padding: 8px 0;
        border-bottom: 2px solid var(--color-text-primary);
        margin-bottom: 12px;
      }

      .exhibit-facet-value {
        font-family: var(--font-sans);
        font-size: 14px;
        line-height: 1.5;
        padding: 4px 0;
      }

      .exhibit-facet-value a {
        color: var(--color-text-secondary);
        text-decoration: none;
        transition: color 0.2s;
      }

      .exhibit-facet-value a:hover {
        color: var(--color-accent);
      }

      /* Recipe Thumbnail Captions */
      .recipe-thumb-caption {
        font-weight: 600;
        font-size: 13px;
        color: var(--color-text-primary);
        line-height: 1.3;
        padding: 10px 8px;
        text-align: center;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .recipe-thumb-caption span {
        display: block;
        text-decoration: none !important;
      }

      .recipe-thumb-caption a,
      .recipe-thumb-caption span a,
      .recipe-thumb-caption span,
      .recipe-thumb a,
      td.recipe-thumb-caption a {
        text-decoration: none !important;
        border-bottom: none !important;
      }

      /* Override Exhibit's default link styles */
      .exhibit-thumbnailView-body a,
      .exhibit-thumbnailView-body a:link,
      .exhibit-thumbnailView-body a:visited,
      .exhibit-thumbnailView-body a:hover {
        text-decoration: none !important;
        border-bottom: none !important;
      }

      /* Recipe Cards - Square aspect ratio */
      .recipe-thumb {
        background: white;
        border: 1px solid var(--color-border);
        border-radius: 8px;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
        aspect-ratio: 1;
      }

      .recipe-thumb:hover {
        border-color: var(--color-accent);
        box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.05);
      }

      .recipe-thumb-wrapper {
        background: var(--color-bg-subtle);
        width: 100%;
        flex: 1;
        overflow: hidden;
      }

      .recipe-thumb-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.3s;
      }

      .recipe-thumb:hover .recipe-thumb-wrapper img {
        transform: scale(1.05);
      }

      /* Ensure uniform card grid */
      .exhibit-thumbnailView-body {
        display: grid !important;
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)) !important;
        gap: 16px !important;
        padding: 10px !important;
      }

      .exhibit-thumbnailView-body table {
        margin: 0 !important;
      }

      /* Remove underlines from all links */
      a {
        text-decoration: none !important;
        border-bottom: none !important;
      }

      /* Hide missing field facet values - aggressive approach */
      .exhibit-facet-value:has(a[title*="missing"]) {
        display: none !important;
      }

      a[title*="missing this field"] {
        display: none !important;
      }

      a[title="(missing this field)"] {
        display: none !important;
      }

      /* Hide parent div if it contains missing text */
      div:has(> a[title*="missing"]) {
        display: none !important;
      }

      /* Hide Exhibit export button and bookmark button */
      .exhibit-copyButton,
      .exhibit-bookmarkButton,
      img[src*="copy-button"],
      img[src*="liveclipboard"],
      img[src*="bookmark-icon"] {
        display: none !important;
      }

      /* Keep Exhibit logo visible */
      [data-ex-role="logo"],
      [data-ex-role="logo"] img,
      [data-ex-role="logo"] * {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }

      /* Let Exhibit handle checkboxes naturally - don't override */

      /* Keep the main Exhibit logo visible */
      [data-ex-role="logo"],
      [data-ex-role="logo"] * {
        display: block !important;
      }

      /* Modal Styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(17, 24, 39, 0.7);
        backdrop-filter: blur(4px);
      }

      .modal-content {
        background-color: white;
        margin: 3% auto;
        padding: 32px;
        border-radius: 12px;
        width: 85%;
        max-width: 900px;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 24px;
        padding-bottom: 20px;
        border-bottom: 1px solid var(--color-border);
      }

      .modal-title {
        font-size: 24px;
        font-weight: 700;
        color: var(--color-text-primary);
        letter-spacing: -0.02em;
        line-height: 1.3;
        margin: 0;
      }

      .close-btn {
        font-size: 32px;
        font-weight: 300;
        color: var(--color-text-tertiary);
        cursor: pointer;
        line-height: 1;
        padding: 4px;
        border-radius: 6px;
        transition: all 0.2s;
        background: transparent;
        border: none;
      }

      .close-btn:hover {
        color: var(--color-text-primary);
        background: var(--color-bg-subtle);
      }
      /* Review Items */
      .review-item {
        margin: 20px 0;
        padding: 20px;
        background: var(--color-bg-subtle);
        border-left: 4px solid var(--color-accent);
        border-radius: 8px;
        transition: all 0.2s;
      }

      .review-item:hover {
        background: #f3f4f6;
        transform: translateX(4px);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
      }

      .review-text {
        line-height: 1.7;
        color: var(--color-text-secondary);
        font-size: 14px;
      }

      /* Attribute Highlights */
      .highlight {
        padding: 3px 6px;
        border-radius: 4px;
        font-weight: 600;
        font-size: 13px;
      }

      .hl-audienceenjoyment {
        background-color: #fef3c7;
        color: #92400e;
      }
      .hl-tasteflavor {
        background-color: #d1fae5;
        color: #065f46;
      }
      .hl-texturemouthfeel {
        background-color: #dbeafe;
        color: #1e40af;
      }
      .hl-mealtype {
        background-color: #e9d5ff;
        color: #6b21a8;
      }
      .hl-occasionholiday {
        background-color: #fed7aa;
        color: #9a3412;
      }
      .hl-cuisinetype {
        background-color: #fce7f3;
        color: #9f1239;
      }

      /* Legend */
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin: 20px 0;
        padding: 16px;
        background: white;
        border: 1px solid var(--color-border);
        border-radius: 8px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        font-size: 13px;
        font-weight: 500;
        color: var(--color-text-secondary);
      }

      .legend-color {
        width: 24px;
        height: 16px;
        margin-right: 8px;
        border-radius: 4px;
      }
      .view-reviews-btn {
        display: inline-block;
        width: 100%;
        margin-top: 16px;
        padding: 14px 20px;
        background: var(--color-text-primary);
        color: white;
        border-radius: 8px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 600;
        font-family: var(--font-sans);
        border: none;
        transition: all 0.2s;
        text-align: center;
      }

      .view-reviews-btn:hover {
        background: #374151;
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      }
      /* Search Box Styling */
      .search-container {
        margin-bottom: 20px;
      }

      .search-container > b {
        font-size: 13px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        color: var(--color-text-primary);
      }

      .search-wrapper {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .search-input {
        flex: 1;
        padding: 10px 14px;
        border: 2px solid var(--color-border);
        border-radius: 6px;
        font-size: 14px;
        font-family: var(--font-sans);
        outline: none;
        transition: all 0.2s;
        background: white;
      }

      .search-input:focus {
        border-color: var(--color-accent);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      .search-button {
        padding: 10px 18px;
        background: var(--color-accent);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        font-family: var(--font-sans);
        transition: all 0.2s;
      }

      .search-button:hover {
        background: var(--color-accent-hover);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
      }

      .clear-button {
        padding: 10px 16px;
        background: var(--color-bg-subtle);
        color: var(--color-text-secondary);
        border: 2px solid var(--color-border);
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        font-family: var(--font-sans);
        transition: all 0.2s;
      }

      .clear-button:hover {
        background: #ffffff;
        border-color: var(--color-text-tertiary);
      }

      .search-hint {
        font-size: 12px;
        color: var(--color-text-tertiary);
        margin-top: 6px;
        line-height: 1.4;
      }

      .search-status {
        margin-top: 10px;
        padding: 10px 14px;
        background: #eff6ff;
        border-left: 3px solid var(--color-accent);
        border-radius: 6px;
        font-size: 13px;
        display: none;
      }

      .search-status.active {
        display: block;
      }

      .search-status-label {
        font-weight: 600;
        color: var(--color-accent);
      }

      .search-status-terms {
        color: var(--color-text-primary);
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        background: white;
        padding: 3px 8px;
        border-radius: 4px;
        margin-left: 6px;
        font-size: 12px;
      }
      /* Hide default Exhibit search box */
      .exhibit-facet-header-filterControl {
        display: none !important;
      }
      /* Recipe Modal */
      .recipe-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        z-index: 10000;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
      }
      .recipe-modal-content {
        position: relative;
        background: white;
        max-width: 1000px;
        margin: 0 auto;
        border-radius: 4px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }
      .recipe-modal-close {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        background: white;
        border: 1px solid var(--color-border);
        border-radius: 8px;
        font-size: 24px;
        line-height: 38px;
        cursor: pointer;
        z-index: 10;
        color: var(--color-text-tertiary);
        transition: all 0.2s;
        font-weight: 300;
      }

      .recipe-modal-close:hover {
        background: var(--color-bg-subtle);
        border-color: var(--color-text-tertiary);
        color: var(--color-text-primary);
        transform: rotate(90deg);
      }
      .recipe-card {
        background: white;
        max-width: 100%;
        overflow: hidden;
      }
      /* Clickable thumbnails */
      .recipe-thumb {
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }
      .recipe-thumb:hover {
        transform: translateY(-4px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }
      .recipe-thumb-caption {
        cursor: pointer;
        transition: color 0.2s;
      }
      .recipe-thumb:hover .recipe-thumb-caption {
        color: #333;
        font-weight: 500;
      }
      .recipe-header {
        display: flex;
        gap: 24px;
        padding: 32px;
        padding-top: 64px;
        border-bottom: 1px solid var(--color-border);
        align-items: flex-start;
        background: var(--color-bg-subtle);
      }
      .recipe-image-wrapper {
        flex-shrink: 0;
        width: 160px;
        height: 160px;
        border: 1px solid var(--color-border);
        border-radius: 12px;
        overflow: hidden;
        background: white;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      }

      .recipe-image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .recipe-header-info {
        flex: 1;
        min-width: 0;
      }
      .recipe-title {
        margin: 0 0 12px 0;
        font-size: 28px;
        font-weight: 700;
        color: var(--color-text-primary);
        line-height: 1.2;
        letter-spacing: -0.02em;
      }
      .recipe-meta {
        display: flex;
        gap: 16px;
        font-size: 14px;
        color: var(--color-text-tertiary);
        font-weight: 500;
      }

      .recipe-meta-item {
        padding: 0;
      }

      .recipe-meta-item:not(:last-child)::after {
        content: "•";
        margin-left: 16px;
        color: var(--color-border);
      }
      .recipe-content {
        padding: 24px 32px;
        max-width: 100%;
        box-sizing: border-box;
        background: white;
      }

      .recipe-columns {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
        max-width: 100%;
      }
      @media (max-width: 900px) {
        .recipe-columns {
          grid-template-columns: 1fr;
        }
        .recipe-header {
          flex-direction: column;
          align-items: flex-start;
        }
        .recipe-image-wrapper {
          width: 100%;
          height: 180px;
        }
      }
      .recipe-column {
        min-width: 0;
      }
      .recipe-section {
        background: white;
        border: 1px solid var(--color-border);
        border-radius: 8px;
        padding: 20px;
        box-sizing: border-box;
      }

      /* Hide empty sections */
      .recipe-section:empty {
        display: none;
      }

      .recipe-section h4 {
        margin: 0 0 16px 0;
        color: var(--color-text-primary);
        font-size: 13px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .ingredients-list,
      .instructions-list {
        margin: 0;
        padding-left: 24px;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      .ingredients-list li,
      .instructions-list li {
        margin: 8px 0;
        line-height: 1.6;
        color: var(--color-text-secondary);
        font-size: 14px;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      .ingredients-list li::marker {
        color: var(--color-text-tertiary);
      }

      .instructions-list li::marker {
        color: var(--color-accent);
        font-weight: 600;
      }
      .recipe-footer {
        border-top: 1px solid #e0e0e0;
        padding-top: 12px;
      }
      .recipe-tags {
        margin-bottom: 16px;
        padding: 14px;
        background: var(--color-bg-subtle);
        border: 1px solid var(--color-border);
        border-radius: 8px;
        font-size: 13px;
        line-height: 1.6;
        color: var(--color-text-secondary);
      }
      .view-reviews-btn {
        width: 100%;
        padding: 10px;
        background: #333;
        color: white;
        border: none;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .view-reviews-btn:hover {
        background: #555;
      }
    </style>
  </head>
  <body>
    <table id="header">
      <tr style="vertical-align: middle;">
        <td>
          <h1>Food Recipe Facet Search (500 Recipes)</h1>
          <p>Browse 500 top recipes with LLM-extracted subjective features from 10,000 reviews.</p>
        </td>
      </tr>
    </table>

    <div id="body">
      <table id="exhibit" style="width: 100%; border-spacing: 10px; border: 0;">
        <tr>
          <td class="facet-column">
            <div class="search-container">
              <b>Search Attributes</b>
              <div class="search-wrapper">
                <input type="text"
                       id="customSearchBox"
                       class="search-input"
                       placeholder="e.g., Christmas food for my father" />
                <button class="search-button" onclick="performSmartSearch()">Search</button>
                <button class="clear-button" onclick="clearSearch()">Clear</button>
              </div>
              <div class="search-hint">Try: "spicy Asian dinner" or "Thanksgiving dessert" (Press Enter to search)</div>
              <div id="searchStatus" class="search-status">
                <span class="search-status-label">Searching for:</span>
                <span id="searchTermsDisplay" class="search-status-terms"></span>
              </div>
            </div>
            <!-- Removed TextSearch facet - implementing custom search instead -->
            <hr />
            <div data-ex-role="facet" data-ex-expression=".audience_attributes" data-ex-facet-label="Audience" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-expression=".occasion_attributes" data-ex-facet-label="Occasion" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-expression=".texture_attributes" data-ex-facet-label="Texture" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-expression=".taste_attributes" data-ex-facet-label="Taste & Flavor" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
          </td>
          <td class="view-column">
            <div data-ex-role="viewPanel">
              <!-- Recipe Detail Modal -->
              <div id="recipeModal" class="recipe-modal" style="display: none;">
                <div class="recipe-modal-content">
                  <button class="recipe-modal-close" onclick="closeRecipeModal()">&times;</button>
                  <div id="recipeModalBody"></div>
                </div>
              </div>

              <div data-ex-role="view"
                   data-ex-view-class="Thumbnail"
                   data-ex-show-all="true"
                   data-ex-paginate="true"
                   data-ex-possible-orders=".aggregated_rating, .review_count, .calories, .label">
                <table data-ex-role="lens" class="recipe-thumb" style="display: none;">
                  <tr>
                    <td class="recipe-thumb-image">
                      <div class="recipe-thumb-wrapper">
                        <img data-ex-src-content=".thumbnail" alt="recipe thumbnail" />
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td class="recipe-thumb-caption"><span data-ex-content="value"></span></td>
                  </tr>
                  <!-- Hidden data for modal -->
                  <tr style="display: none;">
                    <td>
                      <span class="recipe-data" data-ex-content=".id" data-field="id"></span>
                      <span class="recipe-data" data-ex-content=".label" data-field="name"></span>
                      <span class="recipe-data" data-ex-content=".image" data-field="image"></span>
                      <span class="recipe-data" data-ex-content=".aggregated_rating" data-field="rating"></span>
                      <span class="recipe-data" data-ex-content=".review_count" data-field="reviews"></span>
                      <span class="recipe-data" data-ex-content=".calories" data-field="calories"></span>
                      <span class="recipe-data" data-ex-content=".ingredients" data-field="ingredients"></span>
                      <span class="recipe-data" data-ex-content=".instructions" data-field="instructions"></span>
                      <span class="recipe-data" data-ex-content=".subjective_attributes" data-field="attributes"></span>
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          </td>
          <td class="facet-column">
            <div data-ex-role="facet" data-ex-expression=".meal_type_attributes" data-ex-facet-label="Meal Type" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-expression=".type_attributes" data-ex-facet-label="Cuisine" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-facet-class="NumericRange" data-ex-expression=".calories" data-ex-facet-label="Calories" data-ex-height="10em" data-ex-interval="100" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div style="text-align: center" data-ex-role="logo"></div>
          </td>
        </tr>
      </table>
    </div>

    <!-- Review Modal -->
    <div id="reviewModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <div class="modal-title" id="modalTitle">Recipe Reviews</div>
          <span class="close-btn" onclick="closeModal()">&times;</span>
        </div>
        <div class="legend">
          <div class="legend-item"><div class="legend-color hl-audienceenjoyment"></div> Audience</div>
          <div class="legend-item"><div class="legend-color hl-tasteflavor"></div> Taste & Flavor</div>
          <div class="legend-item"><div class="legend-color hl-texturemouthfeel"></div> Texture</div>
          <div class="legend-item"><div class="legend-color hl-mealtype"></div> Meal Type</div>
          <div class="legend-item"><div class="legend-color hl-occasionholiday"></div> Occasion</div>
          <div class="legend-item"><div class="legend-color hl-cuisinetype"></div> Cuisine</div>
        </div>
        <div id="modalReviews"></div>
      </div>
    </div>

    <script>
      let reviewData = null;
      let exhibitData = null;

      // Load exhibit data
      function loadExhibitData() {
        if (exhibitData) return Promise.resolve(exhibitData);

        return fetch('food-exhibit-data-500recipes.json')
          .then(response => response.json())
          .then(data => {
            exhibitData = data;
            return data;
          })
          .catch(err => {
            console.error('Error loading exhibit data:', err);
            return null;
          });
      }

      // Reviews are embedded in exhibit data - no separate load needed
      function getReviewsFromExhibit(recipeId) {
        if (!exhibitData) return [];

        const recipe = exhibitData.items.find(item => item.id == recipeId);
        return recipe ? recipe.reviews || [] : [];
      }

      // Get currently selected facet values by examining DOM
      function getSelectedFacets() {
        const allSelected = [];

        console.log('=== Searching for selected facets ===');

        // Look for all facet divs
        const facetDivs = document.querySelectorAll('[data-ex-role="facet"]');
        console.log('Found facet divs:', facetDivs.length);

        facetDivs.forEach(facetDiv => {
          const expression = facetDiv.getAttribute('data-ex-expression');
          const facetClass = facetDiv.getAttribute('data-ex-facet-class');

          // Skip numeric ranges (like calories) and search facets
          if (!expression || expression.includes('NumericRange') || facetClass === 'NumericRange' || facetDiv.querySelector('[data-ex-facet-class="TextSearch"]')) {
            return; // Skip numeric and search facets
          }

          console.log('Examining facet:', expression);

          // Look for all divs within this facet that might be facet values
          // Exhibit uses specific class names for facet values
          const facetValues = facetDiv.querySelectorAll('div[class*="facet"], div[class*="value"]');
          console.log('  Found potential value elements:', facetValues.length);

          // Also try more generic approach - find all divs with text content
          const allDivs = facetDiv.querySelectorAll('div');
          let foundInThisFacet = 0;

          allDivs.forEach(div => {
            // Check if this div looks like a selected facet value
            const classes = div.className || '';
            const text = div.textContent?.trim() || '';
            const computedStyle = window.getComputedStyle(div);

            // Look for indicators of selection (broader check)
            const isSelected = classes.includes('selected') ||
                             classes.includes('checked') ||
                             classes.includes('exhibit-facet-value-selected') ||
                             div.style.fontWeight === 'bold' ||
                             div.style.fontWeight === '700' ||
                             computedStyle.fontWeight === 'bold' ||
                             computedStyle.fontWeight === '700' ||
                             parseInt(computedStyle.fontWeight) >= 700;

            if (isSelected && text && text.length > 0 && text.length < 200) {
              // Remove count like "(123)" and also leading numbers like "474 husband"
              let facetValue = text.split('(')[0].trim();

              // Remove leading number and space (e.g., "474 husband" -> "husband")
              facetValue = facetValue.replace(/^\d+\s+/, '');

              if (facetValue && !allSelected.includes(facetValue)) {
                console.log('  -> Found selected:', facetValue, 'in', expression, '(from:', text.substring(0, 50), ')');
                allSelected.push(facetValue);
                foundInThisFacet++;
              }
            }
          });

          console.log('  Found', foundInThisFacet, 'selected values in this facet');
        });

        console.log('Final selected facets:', allSelected);

        return {
          byDimension: {},
          all: allSelected
        };
      }

      // Show reviews for the currently displayed recipe
      function showReviewsForCurrentRecipe(button) {
        // Find the recipe detail div that contains this button
        const detailDiv = button.closest('.recipe-detail');

        // Get recipe name from the h2
        const recipeName = detailDiv.querySelector('h2 span').textContent;

        // Get selected facets
        const selectedFacets = getSelectedFacets();

        // Load exhibit data to find recipe ID by name
        loadExhibitData().then(exhibitData => {
          if (!exhibitData) {
            alert('Could not load exhibit data. Please try again.');
            return;
          }

          // Find recipe by name
          const recipe = exhibitData.items.find(item => item.name === recipeName);

          if (!recipe) {
            console.error('Could not find recipe:', recipeName);
            alert('Could not find recipe. Please try again.');
            return;
          }

          const recipeId = recipe.id;

          // Get reviews from embedded exhibit data (already loaded)
          const reviews = getReviewsFromExhibit(recipeId);

            let titleText = `Reviews for: ${recipeName}`;
            if (selectedFacets.all.length > 0) {
              titleText += ` (filtering for: ${selectedFacets.all.join(', ')})`;
            }
            document.getElementById('modalTitle').textContent = titleText;

            let html = '';
            if (reviews.length === 0) {
              html = '<p>No reviews with extracted attributes found for this recipe.</p>';
            } else {
              // Process reviews and calculate match counts
              const processedReviews = reviews.map(review => {
                const result = highlightSpans(review, selectedFacets.all);
                return {
                  html: result.html,
                  matchCount: result.matchCount,
                  review: review
                };
              });

              // Debug: Log review attributes to see what we're matching against
              console.log('Total reviews:', processedReviews.length);
              console.log('Selected facets:', selectedFacets.all);

              if (selectedFacets.all.length > 0 && reviews.length > 0) {
                console.log('Sample review attributes:', reviews[0].attributes?.map(a => a.entity).slice(0, 10));
              }

              // Filter reviews if facets are selected (only show reviews with matches)
              let filteredReviews = processedReviews;

              if (selectedFacets.all.length > 0) {
                filteredReviews = processedReviews.filter(item => item.matchCount > 0);
                console.log('Filtered reviews (with matches):', filteredReviews.length);

                if (filteredReviews.length === 0) {
                  console.warn('No matching reviews found! This might indicate a mismatch between facet values and review entities.');
                }
              }

              // Sort by match count (most matches first)
              filteredReviews.sort((a, b) => b.matchCount - a.matchCount);

              if (filteredReviews.length === 0) {
                html = '<p>No reviews found matching the selected attributes.</p>';
              } else {
                // Show reviews
                filteredReviews.forEach(item => {
                  const matchBadge = item.matchCount > 0
                    ? `<span style="background: #4a90e2; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; font-weight: bold; margin-bottom: 8px; display: inline-block;">${item.matchCount} match${item.matchCount > 1 ? 'es' : ''}</span>`
                    : '';
                  html += `<div class="review-item" style="${item.matchCount > 0 ? 'border-left-width: 5px;' : ''}">`;
                  if (matchBadge) html += matchBadge;
                  html += `<div class="review-text">${item.html}</div>`;
                  html += `</div>`;
                });
              }
            }

            document.getElementById('modalReviews').innerHTML = html;
            document.getElementById('reviewModal').style.display = 'block';
        });
      }

      // Highlight spans in review text
      function highlightSpans(review, selectedAttributes = []) {
        const text = review.review_text || '';
        const attributes = review.attributes || [];

        // Debug: Log reviews with no attributes
        if (!attributes || attributes.length === 0) {
          console.log('Review with NO attributes:', text.substring(0, 100) + '...');
        }

        // Simply normalize selected attributes for matching (lowercase, trim)
        // Matching will be done against normalized_entity field in data
        const normalizedSelected = selectedAttributes.map(a => a.toLowerCase().trim());

        // Filter spans based on selected attributes (if any)
        const spans = [];
        let matchCount = 0;
        let invalidSpans = 0;

        attributes.forEach(attr => {
          // Check if span exists and has valid start/end properties
          if (!attr.span || attr.span.start === undefined || attr.span.end === undefined) {
            console.warn('Attribute missing span data:', attr.entity, 'dimension:', attr.dimension);
            invalidSpans++;
            return; // Skip attributes without valid spans
          }

          // Validate span indices
          const start = attr.span.start;
          const end = attr.span.end;

          if (start < 0 || end > text.length || start >= end) {
            console.warn('Invalid span:', attr.entity, 'start:', start, 'end:', end, 'text length:', text.length);
            invalidSpans++;
            return; // Skip invalid spans
          }

          // Match against normalized_entity (which is pre-computed in data)
          // This allows facet "husband" to match review entity "hubby"
          // while preserving original span text
          const normalizedEntity = (attr.normalized_entity || attr.entity || '').toLowerCase().trim();

          // If no filters, show all. Otherwise, check if normalized_entity matches
          const shouldShow = selectedAttributes.length === 0 ||
                           normalizedSelected.includes(normalizedEntity);

          if (shouldShow) {
            const spanText = text.substring(start, end);

            // Debug: check if span is empty or just whitespace
            if (!spanText.trim()) {
              console.warn('Empty span text for:', attr.entity, 'at', start, '-', end);
              invalidSpans++;
              return;
            }

            spans.push({
              start: start,
              end: end,
              dimension: attr.dimension,
              entity: attr.entity
            });

            // Count matches for selected attributes
            if (selectedAttributes.length > 0 && normalizedSelected.includes(normalizedEntity)) {
              matchCount++;
            }
          }
        });

        // Log summary if there were issues
        if (attributes.length > 0 && spans.length === 0) {
          console.log('Review has', attributes.length, 'attributes but 0 valid spans (', invalidSpans, 'invalid/missing)');
        }

        spans.sort((a, b) => a.start - b.start);

        let result = '';
        let lastEnd = 0;

        spans.forEach(span => {
          if (span.start >= lastEnd) {
            result += escapeHtml(text.substring(lastEnd, span.start));
            const dimClass = span.dimension.replace(/_/g, '');
            result += `<span class="highlight hl-${dimClass}" title="${span.dimension}: ${span.entity}">`;
            result += escapeHtml(text.substring(span.start, span.end));
            result += `</span>`;
            lastEnd = span.end;
          }
        });

        result += escapeHtml(text.substring(lastEnd));

        return {
          html: result,
          matchCount: matchCount
        };
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Close modal
      function closeModal() {
        document.getElementById('reviewModal').style.display = 'none';
      }

      // Click outside modal to close
      window.onclick = function(event) {
        const modal = document.getElementById('reviewModal');
        if (event.target == modal) {
          closeModal();
        }
      }

      // Smart search functionality
      // Build an index of all facet values grouped by category
      function buildFacetIndex() {
        const index = [];
        const facetDivs = document.querySelectorAll('[data-ex-role="facet"]');

        facetDivs.forEach(facetDiv => {
          const expression = facetDiv.getAttribute('data-ex-expression') || '';
          const facetClass = facetDiv.getAttribute('data-ex-facet-class');
          if (!expression || facetClass === 'NumericRange') return;

          const category = expression.replace('.', '').replace('_attributes', '');

          // Find all clickable facet value elements
          // Exhibit renders them in various ways, so try multiple selectors
          const values = facetDiv.querySelectorAll('.exhibit-facet-value, div[class*="facet-value"]');
          values.forEach(elem => {
            // Get the raw text and strip leading count number
            const rawText = elem.textContent.trim();
            // Facet values look like "134 Christmas" or "1 daughter" - strip leading number
            const value = rawText.replace(/^\d+\s+/, '').replace(/\s*\(\d+\)\s*$/, '').trim();
            if (!value || value.includes('missing')) return;

            index.push({
              category: category,
              value: value,
              valueLower: value.toLowerCase(),
              element: elem
            });
          });
        });

        console.log('Facet index built:', index.length, 'values. Sample:', index.slice(0, 5).map(e => `[${e.category}] ${e.value}`));
        return index;
      }

      // Find the best matching facet value for a search term
      // Priority: exact match > starts-with > single-word exact within multi-word value
      function findBestMatch(term, facetIndex) {
        const termLower = term.toLowerCase();
        let exactMatches = [];
        let startsWithMatches = [];
        let containsMatches = [];

        facetIndex.forEach(entry => {
          if (entry.valueLower === termLower) {
            exactMatches.push(entry);
          } else if (entry.valueLower.startsWith(termLower + ' ') || entry.valueLower.startsWith(termLower + '-')) {
            startsWithMatches.push(entry);
          } else if (entry.valueLower.includes(termLower)) {
            containsMatches.push(entry);
          }
        });

        // Return exact matches first (could be in multiple categories, that's fine)
        if (exactMatches.length > 0) return exactMatches;

        // Then starts-with, but pick the shortest (most specific) match per category
        if (startsWithMatches.length > 0) {
          startsWithMatches.sort((a, b) => a.value.length - b.value.length);
          // Only return the single best starts-with match
          return [startsWithMatches[0]];
        }

        // For contains matches, only use if the term is a whole word in the value
        // This prevents "birthday" from matching "birthday boy" when "birthday" exists as exact
        const wholeWordMatches = containsMatches.filter(entry => {
          const regex = new RegExp('\\b' + termLower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b');
          return regex.test(entry.valueLower);
        });

        if (wholeWordMatches.length > 0) {
          // Pick the shortest match (most specific)
          wholeWordMatches.sort((a, b) => a.value.length - b.value.length);
          return [wholeWordMatches[0]];
        }

        return [];
      }

      function performSmartSearch() {
        const searchBox = document.getElementById('customSearchBox');
        if (!searchBox) return;

        const query = searchBox.value.trim();
        if (!query) { clearSearch(); return; }

        // Stop words to filter out
        const stopWords = new Set([
          'for', 'my', 'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'of',
          'with', 'from', 'by', 'about', 'as', 'into', 'through', 'during', 'before',
          'after', 'above', 'below', 'between', 'under', 'again', 'further', 'then',
          'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'both', 'each',
          'few', 'more', 'most', 'other', 'some', 'such', 'only', 'own', 'same', 'so',
          'than', 'too', 'very', 'can', 'will', 'just', 'should', 'now', 'i', 'me',
          'food', 'foods', 'dish', 'dishes', 'recipe', 'recipes', 'meal', 'meals'
        ]);

        // Parse query into terms
        const words = query.toLowerCase().replace(/['']/g, "'").split(/\s+/)
          .map(w => w.replace(/'s$/, '').replace(/[^a-z0-9-]/g, ''));
        const searchTerms = words.filter(word => word.length > 1 && !stopWords.has(word));

        if (searchTerms.length === 0) return;

        // Update search status display
        const statusDiv = document.getElementById('searchStatus');
        const termsDisplay = document.getElementById('searchTermsDisplay');
        if (statusDiv && termsDisplay) {
          termsDisplay.textContent = searchTerms.join(', ');
          statusDiv.classList.add('active');
        }

        // Clear existing selections first
        clearAllFacetSelections();

        // Wait for Exhibit to re-render, then do smart selection
        setTimeout(() => {
          const facetIndex = buildFacetIndex();

          // Prioritize single words first, then try multi-word phrases only for unmatched terms
          const allTermCombinations = [];
          searchTerms.forEach(term => allTermCombinations.push(term));
          for (let len = 2; len <= searchTerms.length; len++) {
            for (let i = 0; i <= searchTerms.length - len; i++) {
              allTermCombinations.push(searchTerms.slice(i, i + len).join(' '));
            }
          }

          // Phase 1: Collect all elements to click (without clicking yet)
          const toClick = [];
          const matchedTerms = new Set();

          allTermCombinations.forEach(phrase => {
            const phraseWords = phrase.split(' ');
            if (phraseWords.every(w => matchedTerms.has(w))) return;

            const matches = findBestMatch(phrase, facetIndex);
            if (matches.length > 0) {
              matches.forEach(match => {
                if (!toClick.some(tc => tc.element === match.element)) {
                  toClick.push(match);
                  console.log(`Search: "${phrase}" → [${match.category}] "${match.value}"`);
                }
              });
              phraseWords.forEach(w => matchedTerms.add(w));
            }
          });

          // Phase 2: Click elements sequentially with delays to handle DOM re-renders
          function clickSequentially(items, idx) {
            if (idx >= items.length) return;
            const match = items[idx];
            // Re-find the element in fresh DOM since previous clicks may have re-rendered
            const freshIndex = buildFacetIndex();
            const fresh = freshIndex.find(e => e.category === match.category && e.valueLower === match.valueLower);
            if (fresh && !fresh.element.classList.contains('exhibit-facet-value-selected')) {
              const link = fresh.element.querySelector('a');
              if (link) link.click(); else fresh.element.click();
              console.log('Clicked:', match.value, 'in', match.category);
            }
            setTimeout(() => clickSequentially(items, idx + 1), 200);
          }
          clickSequentially(toClick, 0);

          // Phase 3: Retry with fresh index for any terms that weren't matched
          // (handles cases where Exhibit hadn't finished rendering)
          const unmatchedTerms = searchTerms.filter(t => !matchedTerms.has(t));
          if (unmatchedTerms.length > 0) {
            setTimeout(() => {
              const freshIndex = buildFacetIndex();
              unmatchedTerms.forEach(term => {
                const matches = findBestMatch(term, freshIndex);
                matches.forEach(match => {
                  if (!match.element.classList.contains('exhibit-facet-value-selected')) {
                    const retryLink = match.element.querySelector('a');
                    if (retryLink) retryLink.click(); else match.element.click();
                    console.log(`Search retry: "${term}" → [${match.category}] "${match.value}"`);
                  }
                });
              });
            }, 500);
          }
        }, 300);
      }

      // Clear all facet selections
      function clearAllFacetSelections() {
        document.querySelectorAll('.exhibit-facet-value').forEach(elem => {
          if (elem.classList.contains('exhibit-facet-value-selected')) {
            elem.click();
          }
        });
      }

      function clearSearch() {
        // Only clear the search input box
        const searchBox = document.getElementById('customSearchBox');
        if (searchBox) {
          searchBox.value = '';
          searchBox.focus();
        }

        // Hide search status
        const statusDiv = document.getElementById('searchStatus');
        if (statusDiv) {
          statusDiv.classList.remove('active');
        }
      }

      // Support Enter key for search
      // Wait for Exhibit to fully initialize
      function initializeCustomSearch() {
        const searchBox = document.getElementById('customSearchBox');
        if (searchBox) {
          searchBox.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              performSmartSearch();
            }
          });

          // Add clear button on Escape
          searchBox.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
              clearSearch();
            }
          });
        }
      }

      // Open recipe modal
      function openRecipeModal(thumbElement) {
        const modal = document.getElementById('recipeModal');
        const modalBody = document.getElementById('recipeModalBody');

        // Extract recipe data from thumbnail
        const dataSpans = thumbElement.querySelectorAll('.recipe-data');
        const recipeData = {};
        dataSpans.forEach(span => {
          const field = span.getAttribute('data-field');
          recipeData[field] = span.textContent.trim();
        });

        // Build modal content
        const html = `
          <div class="recipe-card">
            <div class="recipe-header">
              <div class="recipe-image-wrapper">
                <img src="${recipeData.image}" alt="${recipeData.name}" />
              </div>
              <div class="recipe-header-info">
                <h2 class="recipe-title">${recipeData.name}</h2>
                <div class="recipe-meta">
                  <span class="recipe-meta-item">Rating: ${recipeData.rating}</span>
                  <span class="recipe-meta-item">${recipeData.reviews} reviews</span>
                  <span class="recipe-meta-item">${recipeData.calories} cal</span>
                </div>
              </div>
            </div>

            <div class="recipe-content">
              <div class="recipe-columns">
                <div class="recipe-column">
                  <div class="recipe-section">
                    <h4>Ingredients</h4>
                    <ul class="ingredients-list">${formatList(recipeData.ingredients, 'li')}</ul>
                  </div>
                </div>

                <div class="recipe-column">
                  <div class="recipe-section">
                    <h4>Instructions</h4>
                    <ol class="instructions-list">${formatList(recipeData.instructions, 'li')}</ol>
                  </div>
                </div>
              </div>

              <div class="recipe-footer">
                <div class="recipe-tags">
                  <strong>Subjective Attributes:</strong> ${formatAttributes(recipeData.attributes, recipeData.name)}
                </div>
                <button class="view-reviews-btn" onclick="showReviewsFromModal('${recipeData.name.replace(/'/g, "\\'")}')">
                  View Reviews with Highlights
                </button>
              </div>
            </div>
          </div>
        `;

        modalBody.innerHTML = html;
        modal.style.display = 'block';
        document.body.style.overflow = 'hidden';
      }

      // Close recipe modal
      function closeRecipeModal() {
        const modal = document.getElementById('recipeModal');
        modal.style.display = 'none';
        document.body.style.overflow = '';
      }

      // Format comma-separated list into HTML list items
      function formatList(text, tag) {
        const items = text.split(',').map(s => s.trim()).filter(s => s);
        return items.map(item => `<${tag}>${item}</${tag}>`).join('');
      }

      // Format attributes with vegetarian alternative labeling
      function formatAttributes(text, recipeName) {
        const hasMeat = /chicken|beef|pork|lamb|turkey|bacon|sausage|ham|steak|meat/i.test(recipeName);
        if (hasMeat && /vegetarian/i.test(text)) {
          return text.replace(/(vegetarian)/gi, '$1 <span style="color: #999; font-size: 0.85em;">(alternative)</span>');
        }
        return text;
      }

      // Show reviews from modal
      function showReviewsFromModal(recipeName) {
        // Get selected facets
        const selectedFacets = getSelectedFacets();

        // Load exhibit data to find recipe
        loadExhibitData().then(exhibitData => {
          if (!exhibitData) {
            alert('Could not load exhibit data. Please try again.');
            return;
          }

          // Find recipe by name
          const recipe = exhibitData.items.find(item => item.name === recipeName);

          if (!recipe) {
            console.error('Could not find recipe:', recipeName);
            alert('Could not find recipe. Please try again.');
            return;
          }

          const recipeId = recipe.id;

          // Get reviews from embedded exhibit data
          const reviews = getReviewsFromExhibit(recipeId);

          let titleText = `Reviews for: ${recipeName}`;
          if (selectedFacets.all.length > 0) {
            titleText += ` (filtering for: ${selectedFacets.all.join(', ')})`;
          }
          document.getElementById('modalTitle').textContent = titleText;

          let html = '';
          if (reviews.length === 0) {
            html = '<p>No reviews with extracted attributes found for this recipe.</p>';
          } else {
            // Process reviews and calculate match counts using highlightSpans
            const processedReviews = reviews.map(review => {
              const result = highlightSpans(review, selectedFacets.all);
              return {
                html: result.html,
                matchCount: result.matchCount,
                review: review
              };
            });

            // Filter reviews if facets are selected
            let filteredReviews = processedReviews;
            if (selectedFacets.all.length > 0) {
              filteredReviews = processedReviews.filter(item => item.matchCount > 0);
            }

            // Sort by match count
            filteredReviews.sort((a, b) => b.matchCount - a.matchCount);

            if (filteredReviews.length === 0 && selectedFacets.all.length > 0) {
              html = '<p>No reviews found matching the selected attributes.</p>';
            } else {
              // Show reviews
              filteredReviews.forEach(item => {
                const matchBadge = item.matchCount > 0
                  ? `<span style="background: #4a90e2; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; font-weight: bold; margin-bottom: 8px; display: inline-block;">${item.matchCount} match${item.matchCount > 1 ? 'es' : ''}</span>`
                  : '';
                html += `<div class="review-item" style="${item.matchCount > 0 ? 'border-left-width: 5px;' : ''}">`;
                if (matchBadge) html += matchBadge;
                html += `<div class="review-text">${item.html}</div>`;
                html += `</div>`;
              });
            }
          }

          document.getElementById('modalReviews').innerHTML = html;
          document.getElementById('reviewModal').style.display = 'block';

          // Close recipe modal
          closeRecipeModal();
        });
      }

      // Close modal on ESC key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          closeRecipeModal();
        }
      });

      // Close modal on background click
      document.addEventListener('click', function(e) {
        const modal = document.getElementById('recipeModal');
        if (e.target === modal) {
          closeRecipeModal();
        }
      });

      // Format arrays as proper HTML lists
      function formatRecipeLists() {
        document.querySelectorAll('.ingredients-list').forEach(ul => {
          const content = ul.textContent.trim();
          if (content && !ul.querySelector('li:not([data-ex-content])') && !ul.hasAttribute('data-formatted')) {
            ul.innerHTML = '';
            const items = content.split(',').map(s => s.trim()).filter(s => s);
            if (items.length > 0) {
              items.forEach(item => {
                const li = document.createElement('li');
                li.textContent = item;
                ul.appendChild(li);
              });
              ul.setAttribute('data-formatted', 'true');
            }
          }
        });

        document.querySelectorAll('.instructions-list').forEach(ol => {
          const content = ol.textContent.trim();
          if (content && !ol.querySelector('li:not([data-ex-content])') && !ol.hasAttribute('data-formatted')) {
            ol.innerHTML = '';
            const items = content.split(',').map(s => s.trim()).filter(s => s);
            if (items.length > 0) {
              items.forEach(item => {
                const li = document.createElement('li');
                li.textContent = item;
                ol.appendChild(li);
              });
              ol.setAttribute('data-formatted', 'true');
            }
          }
        });

        // Add "(alternative)" label to vegetarian attributes for meat-based recipes
        document.querySelectorAll('.recipe-card').forEach(card => {
          const title = card.querySelector('.recipe-title');
          const tagsDiv = card.querySelector('.recipe-tags span');

          if (title && tagsDiv && !card.hasAttribute('data-veg-checked')) {
            const recipeName = title.textContent.toLowerCase();
            const hasMeat = /chicken|beef|pork|lamb|turkey|bacon|sausage|ham|steak|meat/.test(recipeName);

            if (hasMeat) {
              const tags = tagsDiv.textContent;
              if (tags.includes('vegetarian') && !tags.includes('(alternative)')) {
                tagsDiv.innerHTML = tags.replace(/(vegetarian)/gi, '$1 <span style="color: #999; font-size: 0.85em;">(alternative)</span>');
              }
            }
            card.setAttribute('data-veg-checked', 'true');
          }
        });
      }


      // Attach click handlers to thumbnails
      function attachThumbnailHandlers() {
        const thumbnails = document.querySelectorAll('.recipe-thumb');
        thumbnails.forEach(thumb => {
          // Remove any existing handlers
          const newThumb = thumb.cloneNode(true);
          thumb.parentNode.replaceChild(newThumb, thumb);

          // Add click handler to entire thumbnail
          newThumb.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            openRecipeModal(this);
            return false;
          }, true);
        });
      }

      // Initialize after DOM is ready
      // Hide "(missing this field)" facet values
      function hideMissingFieldValues() {
        // Find all links with title containing "missing"
        const missingLinks = document.querySelectorAll('a[title*="missing"]');
        missingLinks.forEach(link => {
          // Hide the parent facet value div
          const facetValue = link.closest('.exhibit-facet-value');
          if (facetValue) {
            facetValue.style.display = 'none';
            facetValue.remove(); // Remove from DOM entirely
          }
        });

        // Also check by text content
        const allFacetValues = document.querySelectorAll('.exhibit-facet-value');
        allFacetValues.forEach(facetValue => {
          const text = facetValue.textContent || '';
          if (text.includes('missing this field') || text.includes('(missing')) {
            facetValue.style.display = 'none';
            facetValue.remove(); // Remove from DOM entirely
          }
        });

        // Check all links with "missing" in title
        document.querySelectorAll('a').forEach(link => {
          const title = link.getAttribute('title') || '';
          if (title.toLowerCase().includes('missing')) {
            const parent = link.closest('.exhibit-facet-value');
            if (parent) {
              parent.style.display = 'none';
              parent.remove();
            }
          }
        });
      }

      // Hide Exhibit export and bookmark buttons
      function hideExportButton() {
        document.querySelectorAll('.exhibit-copyButton, .exhibit-bookmarkButton, img[src*="copy-button"], img[src*="liveclipboard"], img[src*="bookmark"]').forEach(el => {
          el.style.display = 'none';
        });
        // Also hide by title attribute
        document.querySelectorAll('img[title*="bookmark"], img[title*="Bookmark"], a[title*="bookmark"]').forEach(el => {
          el.style.display = 'none';
        });
      }

      document.addEventListener('DOMContentLoaded', function() {
        // Wait for Exhibit to initialize
        setTimeout(initializeCustomSearch, 1000);

        // Attach thumbnail handlers after Exhibit renders
        setTimeout(attachThumbnailHandlers, 2000);

        // Hide missing field values once after Exhibit loads
        setTimeout(hideMissingFieldValues, 1500);
        setTimeout(hideMissingFieldValues, 3000); // Second check

        // Hide export button after Exhibit loads
        setTimeout(hideExportButton, 1500);
        setTimeout(hideExportButton, 3000);

        // Re-attach handlers when pagination changes (stable interval)
        setInterval(attachThumbnailHandlers, 2000);

        // Periodically hide missing field values (less frequent)
        setInterval(hideMissingFieldValues, 3000);
      });
    </script>
  </body>
</html>
